An interrupt is a signal that temporarily stops the normal execution flow of a program to immediately handle a specific event or condition. When an interrupt occurs, the processor interrupts its current task, saves its state, and executes a predefined interrupt service routine (ISR) to handle the event. Once the ISR is completed, the processor returns to the interrupted task.
  
In the context of the Arduino Uno, which uses the ATmega328P microcontroller, let's compare external interrupts and software interrupts:

1. **External Interrupts**:
    
    - External interrupts, also known as hardware interrupts, are triggered by external events on specific pins of the microcontroller. The ATmega328P microcontroller has two external interrupt pins, labeled as INT0 (Digital Pin 2) and INT1 (Digital Pin 3). These interrupts can be triggered by a change in the logic level (rising edge, falling edge, or both edges) of the corresponding external signal.
    - External interrupts are useful for responding to real-time events generated by external sensors, switches, or other devices. They allow the microcontroller to interrupt its current execution flow and immediately handle the external event without polling or continuous checking.
    - To use external interrupts in Arduino, you can attach interrupt service routines (ISRs) to the external interrupt pins using the `attachInterrupt()` function.
    
1. **Software Interrupts**:
    
    - Software interrupts, also known as internal interrupts or interrupts generated by software, are triggered by specific instructions in the program code. Unlike external interrupts, software interrupts are not triggered by external events but are initiated programmatically by the user.
    - The ATmega328P microcontroller supports software interrupts through the `interrupt()` function. 
    
External interrupts, pin-change interrupts, and the timer interrupt, can also be used to wake the processor up. This can be very handy, as in sleep mode the processor can be configured to use a lot less power (e.g. around 10 microamps). A rising, falling, or low-level interrupt can be used to wake up a gadget (e.g. if you press a button on it), or a "timer" interrupt might wake it up periodically (e.g. to check the time or temperature).  
  
Pin-change interrupts could be used to wake the processor if a key is pressed on a keypad, or similar.  
  
The processor can also be awoken by a timer interrupt (e.g. a timer reaching a certain value, or overflowing) and certain other events, such as an incoming I2C message.

Available interrupts

Below is a list of interrupts, in priority order, for the Atmega328:  
 ```

 1  Reset 
 2  External Interrupt Request 0  (pin D2)          (INT0_vect)
 3  External Interrupt Request 1  (pin D3)          (INT1_vect)
 4  Pin Change Interrupt Request 0 (pins D8 to D13) (PCINT0_vect)
 5  Pin Change Interrupt Request 1 (pins A0 to A5)  (PCINT1_vect)
 6  Pin Change Interrupt Request 2 (pins D0 to D7)  (PCINT2_vect)
 7  Watchdog Time-out Interrupt                     (WDT_vect)
 8  Timer/Counter2 Compare Match A                  (TIMER2_COMPA_vect)
 9  Timer/Counter2 Compare Match B                  (TIMER2_COMPB_vect)
10  Timer/Counter2 Overflow                         (TIMER2_OVF_vect)
11  Timer/Counter1 Capture Event                    (TIMER1_CAPT_vect)
12  Timer/Counter1 Compare Match A                  (TIMER1_COMPA_vect)
13  Timer/Counter1 Compare Match B                  (TIMER1_COMPB_vect)
14  Timer/Counter1 Overflow                         (TIMER1_OVF_vect)
15  Timer/Counter0 Compare Match A                  (TIMER0_COMPA_vect)
16  Timer/Counter0 Compare Match B                  (TIMER0_COMPB_vect)
17  Timer/Counter0 Overflow                         (TIMER0_OVF_vect)
18  SPI Serial Transfer Complete                    (SPI_STC_vect)
19  USART Rx Complete                               (USART_RX_vect)
20  USART, Data Register Empty                      (USART_UDRE_vect)
21  USART, Tx Complete                              (USART_TX_vect)
22  ADC Conversion Complete                         (ADC_vect)
23  EEPROM Ready                                    (EE_READY_vect)
24  Analog Comparator                               (ANALOG_COMP_vect)
25  2-wire Serial Interface  (I2C)                  (TWI_vect)
26  Store Program Memory Ready                      (SPM_READY_vect)
```

## *EXAMPLE CODE*
```
const byte LED = 13;
const byte BUTTON = 2;

// Interrupt Service Routine (ISR)
void switchPressed ()
{
  if (digitalRead (BUTTON) == HIGH)
    digitalWrite (LED, HIGH);
  else
    digitalWrite (LED, LOW);
}  // end of switchPressed

void setup ()
{
  pinMode (LED, OUTPUT);  // so we can update the LED
  digitalWrite (BUTTON, HIGH);  // internal pull-up resistor
  attachInterrupt (digitalPinToInterrupt (BUTTON), switchPressed, CHANGE);  // attach interrupt handler
}  // end of setup

void loop ()
{
  // loop doing nothing 
} 
```


# digitalPinToInterrupt()


### Description

The `digitalPinToInterrupt()` function takes a pin as an argument, and returns the same pin **if** it can be used as an interrupt. For example, `digitalPinToInterrupt(4)` on an Arduino UNO will not work, as interrupts are only supported on pins 2,3. Therefore it will return the value '-1'

### Syntax

`digitalPinToInterrupt(pin)`

### Parameters

- `pin` - the pin we want to use for an interrupt.
    
### Returns

- The pin to interrupt (e.g. `2`)
    
- If pin is not available for interrupt, returns `-1`.
    

### Example Code

This example checks if a pin can be used as an interrupt.


```
int pin = 2;

void setup() {
  Serial.begin(9600);
  int checkPin = digitalPinToInterrupt(pin);

  if (checkPin == -1) {
    Serial.println("Not a valid interrupt pin!");
  } else {
    Serial.println("Valid interrupt pin.");
  }
}

void loop() {
}
```

# attachInterrupt()

### Description

The first parameter to `attachInterrupt()` is an interrupt number. Normally you should use `digitalPinToInterrupt(pin)` to translate the actual digital pin to the specific interrupt number

### Syntax

`attachInterrupt(digitalPinToInterrupt(pin), ISR, mode)`

### Parameters
`pin`: the Arduino pin number.  
`ISR`: the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine.  
`mode`: defines when the interrupt should be triggered. Four constants are predefined as valid    values:  

- **LOW** to trigger the interrupt whenever the pin is low,  
    
- **CHANGE** to trigger the interrupt whenever the pin changes value  
    
- **RISING** to trigger when the pin goes from low to high,  
    
- **FALLING** for when the pin goes from high to low.  
    

The Due, Zero and MKR1000 boards allow also:  

- **HIGH** to trigger the interrupt whenever the pin is high.
    
### Example Code


```
const byte ledPin = 13;
const byte interruptPin = 2;
volatile byte state = LOW;

void setup() {
  pinMode(ledPin, OUTPUT);
  pinMode(interruptPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(interruptPin), blink, CHANGE);
}

void loop() {
  digitalWrite(ledPin, state);
}

void blink() {
  state = !state;
}
```

# detachInterrupt()

### Description

Turns off the given interrupt.

### Syntax

- `detachInterrupt(digitalPinToInterrupt(pin))`



## Enabling / disabling interrupts
interrupts can be temporarily disabled by clearing the interrupt flag.  
  
**Enable interrupts**  
  
You can enable interrupts with the function call "interrupts" or "sei" like this:  

```

interrupts ();  // or ...
sei ();         // set interrupts flag
```

  
**Disable interrupts**  
  
If you need to disable interrupts you can "clear" the interrupt flag like this:  
  
```

noInterrupts ();  // or ...
cli ();           // clear interrupts flag
```


In the ATmega328P microcontroller, there are several registers related to interrupts and interrupt handling. These registers control various aspects of interrupt functionality, including enabling/disabling interrupts, configuring interrupt sources, and managing interrupt priorities. Here are the main registers:

1. **Global Interrupt Enable of  Status Register (SREG)**:
    
    - The SREG register is the Global Interrupt Enable Register. It contains a single bit, the I-bit (Global Interrupt Enable), which enables or disables all interrupts in the microcontroller.
    - Bit 7 (I-bit): When set (1), enables interrupts globally. When cleared (0), disables interrupts globally.
    ![[Pasted image 20240503224921.png]]
      
2. **Interrupt Mask Registers (GIMSK and PCICR)**:
    
    - The General Interrupt Mask Register (GIMSK) and the Pin Change Interrupt Control Register (PCICR) are used to enable or disable specific interrupts or groups of interrupts.
    
    - GIMSK: Enables or disables individual interrupts 
      ![[Pasted image 20240523210331.png]]
     ###### Bit 6 – INT0:  External Interrupt Request 0 Enable  
     When the INT0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), the external pin interrupt is enabled. The Interrupt Sense Control bits (ISC01 and ISC00) in the External Interrupt Control Register A (EICRA) define whether the external interrupt is activated on rising and/or falling edge of the INT0 pin or level sensed. Activity on the pin will cause an interrupt request even if INT0 is configured as an output. The corresponding interrupt of External Interrupt Request 0 is executed from the INT0 Interrupt Vector.

     ###### Bit 5 – PCIE1: Pin Change Interrupt Enable 1 
     When the PCIE1 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 1 is enabled. Any change on any enabled PCINT11:8 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI1 Interrupt Vector. PCINT11:8 pins are enabled individually by the PCMSK1 Register.

     ###### Bit 4 – PCIE0: Pin Change Interrupt Enable 0 
     When the PCIE0 bit is set (one) and the I-bit in the Status Register (SREG) is set (one), pin change interrupt 0 is enabled. Any change on any enabled PCINT7:0 pin will cause an interrupt. The corresponding interrupt of Pin Change Interrupt Request is executed from the PCI0 Interrupt Vector. PCINT7:0 pins are enabled individually by the PCMSK0 Register.
     
    - PCICR: Enables or disables pin change interrupts for specific groups of pins (PCINT0, PCINT1, PCINT2).
![[Pasted image 20240503230202.png]]
3. **Pin Change Mask Registers (PCMSKx)**:
    
    - The Pin Change Mask Registers (PCMSK0, PCMSK1, PCMSK2) are used to enable or disable pin change interrupts for specific pins within each pin change interrupt group.
    - PCMSK0: Controls pin change interrupts for PCINT7:0.
    - PCMSK1: Controls pin change interrupts for PCINT15:8.
    - PCMSK2: Controls pin change interrupts for PCINT23:16.
    ![[Pasted image 20240503225819.png]]
    There are three
     Pin Change Masks, and each one can enable or disable 8 pins. To enable a pin, you write a “1” to it. One can enable as many pins as you require
    ![[Pasted image 20240503225928.png]]

4. **External Interrupt Control Registers (EICRA and EIMSK)**:
    
    - The External Interrupt Control Registers (EICRA and EIMSK) are used to configure external interrupts (INT0 and INT1) and enable or disable them.
    - EICRA: Configures the trigger edge (rising, falling, or both) for external interrupts.
     ![[Pasted image 20240523212511.png]]![[Pasted image 20240523212555.png]]
    - EIMSK: Enables or disables external interrupts (INT0 and INT1).
     ![[Pasted image 20240523212646.png]]
5. **Timer/Counter Interrupt Mask Registers (TIMSKx)**:
    
    - The Timer/Counter Interrupt Mask Registers (TIMSK0, TIMSK1, TIMSK2) are used to enable or disable interrupts for timer/counters.
    - TIMSK0: Controls interrupts for Timer/Counter0 (e.g., overflow interrupt).
    - TIMSK1: Controls interrupts for Timer/Counter1 (e.g., overflow interrupt, compare match interrupt).
    - TIMSK2: Controls interrupts for Timer/Counter2 (e.g., overflow interrupt, compare match interrupt).

![[Pasted image 20240523213111.png]]
    
Bit 7  -  OCIE2:  Timer/Counter2 Output Compare Match Interrupt Enable

> When the OCIE2 bit is set (one) and the [I-bit](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm#Bit%207%20%20-%20%20I:%20Global%20Interrupt%20Enable) in the [Status Register](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm) is set (one), the Timer/Counter2 Compare Match interrupt is enabled.  The corresponding interrupt (at vector $006) is executed if a compare match in Timer/Counter2 occurs, i.e. when the [OCF2](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm#Bit%207%20%20-%20%20OCF2:%20%20Output%20Compare%20Flag%202) bit is set in the Timer/Counter Interrupt Flag Register - [TIFR](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm)[.](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm)

Bit 6  -  TOIE2:  Timer/Counter2 Overflow Interrupt Enable

> When the TOIE2 bit is set (one) and the [I-bit](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm#Bit%207%20%20-%20%20I:%20Global%20Interrupt%20Enable) in the [Status Register](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm) is set (one), the Timer/Counter2 Overflow interrupt is enabled.  The corresponding interrupt (at vector $008) is executed if an overflow in Timer/Counter2 occurs, i.e. when the [TOV2](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm#Bit%206%20%20-%20%20TOV2:%20%20Timer/Counter2%20Overflow%20Flag) bit is set in the Timer/Counter Interrupt Flag Register - [TIFR](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm).

Bit 5  -  TICIE1:  Timer/Counter1 Input Capture Interrupt Enable

> When the TICIE1 bit is set (one) and the [I-bit](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm#Bit%207%20%20-%20%20I:%20Global%20Interrupt%20Enable) in the [Status Register](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm) is set (one), the Timer/Counter1 Input Capture Event Interrupt is enabled.  The corresponding interrupt (at vector $00A) is executed if a capture triggering event occurs on PD6 (ICP), i.e. when the [ICF1](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm#Bit%205%20%20-%20%20ICF1:%20%20Input%20Capture%20Flag%201) bit is set in the Timer/Counter Interrupt Flag Register - [TIFR](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm).

Bit 4  -  OCIE1A:  Timer/Counter1 Output CompareA Match Interrupt Enable

> When the OCIE1A bit is set (one) and the [I-bit](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm#Bit%207%20%20-%20%20I:%20Global%20Interrupt%20Enable) in the [Status Register](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm) is set (one), the Timer/Counter1 CompareA Match interrupt is enabled.  The corresponding interrupt (at vector $00C) is executed if a CompareA match in Timer/Counter1 occurs, i.e. when the [OCF1A](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm#Bit%204%20%20-%20%20OCF1A:%20%20Output%20Compare%20Flag%201A) bit is set in the Timer/Counter Interrupt Flag Register - [TIFR](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm).

Bit 3  -  OCIE1B:  Timer/Counter1 Output CompareB Match Interrupt Enable

> When the OCIE1B bit is set (one) and the [I-bit](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm#Bit%207%20%20-%20%20I:%20Global%20Interrupt%20Enable) in the [Status Register](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm) is set (one), the Timer/Counter1 CompareB Match interrupt is enabled.  The corresponding interrupt (at vector $00E) is executed if a CompareB match in Timer/Counter1 occurs, i.e. when the [OCF1B](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm#Bit%203%20%20-%20%20OCF1B:%20%20Output%20Compare%20Flag%201B) bit is set in the Timer/Counter Interrupt Flag Register - [TIFR](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm).

Bit 2  -  TOIE1:  Timer/Counter1 Overflow Interrupt Enable

> When the TOIE1 bit is set (one) and the [I-bit](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm#Bit%207%20%20-%20%20I:%20Global%20Interrupt%20Enable) in the [Status Register](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm) is set (one), the Timer/Counter1 Overflow interrupt is enabled.  The corresponding interrupt (at vector $010) is executed if an overflow in Timer/Counter1 occurs, i.e. when the [TOV1](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm#Bit%202%20%20-%20%20TOV1:%20%20Timer/Counter1%20Overflow%20Flag) bit is set in the Timer/Counter Interrupt Flag Register - [TIFR](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm).

Bit 1  -  OCIE0:

Bit 0  -  TOIE0:  Timer/Counter0 Overflow Interrupt Enable

> When the TOIE0 bit is set (one) and the [I-bit](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm#Bit%207%20%20-%20%20I:%20Global%20Interrupt%20Enable) in the [Status Register](https://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm) is set (one), the Timer/Counter0 Overflow interrupt is enabled.  The corresponding interrupt (at vector $012) is executed if an overflow in Timer/Counter0 occurs, i.e. when the [TOV0](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm#Bit%200%20%20-%20%20TOV0:%20%20Timer/Counter0%20Overflow%20Flag) bit is set in the Timer/Counter Interrupt Flag Register - [TIFR](https://web.ics.purdue.edu/~jricha14/Timer_Stuff/TIFR.htm).